const glsl_flow_fs = `precision highp float;\n\nuniform sampler2D u_vector;\nuniform vec2 u_vector_min;\nuniform vec2 u_vector_max;\n//uniform sampler2D u_color_ramp;\n\nuniform vec4 u_bounds;\nuniform vec4 u_data_bounds;\n\nvarying vec2 v_particle_pos;\n\nvec2 returnLonLat(float x_domain, float y_domain, vec2 pos) {\n\n    //need value between 0 and 1, which fract accomplishes\n    float mercator_x = fract(u_bounds.x + pos.x * x_domain);\n    float mercator_y = u_bounds.w + pos.y * y_domain;\n\n    float lon = mercator_x * 360.0 - 180.0;\n    float lat2 = 180.0 - mercator_y * 360.0;\n    float lat = 360.0 / 3.141592654 * atan(exp(lat2 * 3.141592654/180.0)) - 90.0;\n\n    return vec2(lon, lat);\n}\n\nvoid main() {\n\n    //convert from 0-1 to degrees for proper texture value lookup\n    float x_domain = abs(u_bounds.x - u_bounds.z);\n    float y_domain = abs(u_bounds.y - u_bounds.w);\n\n    vec2 coordinate = returnLonLat(x_domain, y_domain, v_particle_pos);\n    float lon = coordinate.x;\n    float lat = coordinate.y;\n\n    //discard if out of bounds\n    if (\n    lat > u_data_bounds.w || lat < u_data_bounds.y ||\n    lon > u_data_bounds.z || lon < u_data_bounds.x\n    ) {\n        discard;\n    }\n\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.33);\n}`
const glsl_flow_fs_screen = `precision highp float;\n\nuniform sampler2D u_screen;\nuniform float u_opacity;\n\nvarying vec2 v_tex_pos;\n\nvoid main() {\n    vec4 color = texture2D(u_screen, 1.0 - v_tex_pos);\n    // a hack to guarantee opacity fade out even with a value close to 1.0\n    gl_FragColor = vec4(floor(255.0 * color * u_opacity) / 255.0);\n}`
const glsl_flow_fs_update = `precision highp float;\n\nuniform sampler2D u_particles;\nuniform sampler2D u_vector;\nuniform vec2 u_vector_res;\nuniform vec2 u_vector_min;\nuniform vec2 u_vector_max;\nuniform float u_rand_seed;\nuniform float u_speed_factor;\nuniform float u_drop_rate;\nuniform float u_drop_rate_bump;\nuniform vec4 u_bounds;\nuniform vec4 u_data_bounds;\n\nvarying vec2 v_tex_pos;\n\n// pseudo-random generator\nconst vec3 rand_constants = vec3(12.9898, 78.233, 4375.85453);\nfloat rand(const vec2 co) {\n    float t = dot(rand_constants.xy, co);\n    return fract(sin(t) * (rand_constants.z + t));\n}\n\n// vector magnitude lookup; use manual bilinear filtering based on 4 adjacent pixels for smooth interpolation\nvec2 lookup_vector(const vec2 uv) {\n    // return texture2D(u_vector, uv).rg; // lower-res hardware filtering\n    vec2 px = 1.0 / u_vector_res;\n    vec2 vc = (floor(uv * u_vector_res)) * px;\n    vec2 f = fract(uv * u_vector_res);\n    vec2 tl = texture2D(u_vector, vc).rg;\n    vec2 tr = texture2D(u_vector, vc + vec2(px.x, 0)).rg;\n    vec2 bl = texture2D(u_vector, vc + vec2(0, px.y)).rg;\n    vec2 br = texture2D(u_vector, vc + px).rg;\n    return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n\nvec2 returnLonLat(float x_domain, float y_domain, vec2 pos) {\n\n    //need value between 0 and 1, which fract accomplishes\n    float mercator_x = fract(u_bounds.x + pos.x * x_domain);\n    float mercator_y = u_bounds.w + pos.y * y_domain;\n\n    float lon = mercator_x * 360.0 - 180.0;\n    float lat2 = 180.0 - mercator_y * 360.0;\n    float lat = 360.0 / 3.141592654 * atan(exp(lat2 * 3.141592654/180.0)) - 90.0;\n\n    return vec2(lon, lat);\n}\n\nvoid main() {\n    vec4 color = texture2D(u_particles, v_tex_pos);\n    vec2 pos = vec2(\n    color.r / 255.0 + color.b,\n    color.g / 255.0 + color.a);// decode particle position from pixel RGBA\n\n    //convert from 0-1 to degrees for proper texture value lookup\n    float x_domain = abs(u_bounds.x - u_bounds.z);\n    float y_domain = abs(u_bounds.y - u_bounds.w);\n\n    vec2 coordinate = returnLonLat(x_domain, y_domain, pos);\n    float lon = coordinate.x;\n    float lat = coordinate.y;\n\n    float lon_domain = u_data_bounds.z - u_data_bounds.x;\n    float lat_domain = u_data_bounds.w - u_data_bounds.y;\n\n    vec2 pos_lookup = vec2(\n    (lon - u_data_bounds.x) / lon_domain,\n    (lat - u_data_bounds.y) / lat_domain\n    );\n\n    vec2 velocity = mix(u_vector_min, u_vector_max, lookup_vector(pos_lookup));\n    float speed_t = length(velocity) / length(u_vector_max);\n\n    // take EPSG:4236 distortion into account for calculating where the particle moved\n    //float distortion = cos(radians(lat));\n    vec2 offset = vec2(velocity.x, -velocity.y) * 0.0001 * u_speed_factor;\n\n    // update particle position, wrapping around the date line\n    pos = fract(1.0 + pos + offset);\n\n    // a random seed to use for the particle drop\n    vec2 seed = (pos + v_tex_pos) * u_rand_seed;\n\n    // drop rate is a chance a particle will restart at random position, to avoid degeneration\n    float drop_rate = u_drop_rate + speed_t * u_drop_rate_bump;\n    float drop = step(1.0 - drop_rate, rand(seed));\n\n    vec2 random_pos = vec2(\n    rand(seed + 1.3),\n    rand(seed + 2.1));\n    pos = mix(pos, random_pos, drop);\n\n    // encode the new particle position back into RGBA\n    gl_FragColor = vec4(\n    fract(pos * 255.0),\n    floor(pos * 255.0) / 255.0);\n}`
const glsl_flow_vs = `precision highp float;\n\nattribute float a_index;\n\nuniform sampler2D u_particles;\nuniform float u_particles_res;\n\nvarying vec2 v_particle_pos;\n\nvoid main() {\n    vec4 color = texture2D(u_particles, vec2(\n    fract(a_index / u_particles_res),\n    floor(a_index / u_particles_res) / u_particles_res));\n\n    // decode current particle position from the pixel's RGBA value\n    v_particle_pos = vec2(\n    color.r / 255.0 + color.b,\n    color.g / 255.0 + color.a);\n\n    gl_PointSize = 1.0;\n    gl_Position = vec4(2.0 * v_particle_pos.x - 1.0, 1.0 - 2.0 * v_particle_pos.y, 0, 1);\n}`
const glsl_flow_vs_quad = `precision highp float;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_tex_pos;\n\nvoid main() {\n    v_tex_pos = a_pos;\n    gl_Position = vec4(1.0 - 2.0 * a_pos, 0, 1);\n}`

export {glsl_flow_fs, glsl_flow_fs_screen, glsl_flow_fs_update, glsl_flow_vs, glsl_flow_vs_quad}